;Сортировка последовательности пузырьком
; input:  A[1] - A[N]
; output: A[1] - A[N] *
<input> 3 2 1 0
;   1 - регистр для приема данных
;   2 - индексный регистр для списка
;   3 - F
;   4 - J
;   5 - I
;   6 - A[I]
;   7 - A[I+1]
;   8 - N-J-1

    load 1    ;R0 ← i
    load =11 ;R0 ← i адрес первого элемента списка
    store 2 ;Ri ← R0
begin:
    read 0    ;Ri ← next input
    jz end      ;if R0 == 0 then IP ← i если 0 то окончание ввода
    store *2    ;M<Ri> ← R0 иначе запишем число в очередной регистр
    load 2  ;   загрузить счетчик в R0
    add =1  ;   продвинуть на 1
    store 2 ;   вернуть в R2
    jmp begin   ; читать следующее число
end:
    load 2  ;последний индекс
    sub =11   ;количество элементов
    store 1 ;N сохранить в R1
;   инициализация J
    load =1
    store 4 ;начальное значение J
; ЦИКЛ ДЛЯ J=1 ДО N-1 ШАГ 1
loopJ:
; F=0
    load =0
    store 3 ;установить значение F
    load =1
    store 5 ;начальное значение I
; ЦИКЛ ДЛЯ I=1 ДО N-J-1 ШАГ 1
loopI:
    load 5  ; I = 1
    add =10  ; получить номер регистра, где хранится A[i], 11 для i=1
    store 6 ; соханить номер в R6
    add =1  ; получить номер регистра, где хранится A[i+1], 12 для i=2
    store 7 ; соханить номер в R7
    load *6 ; загрузить A[i]
    sub *7  ; отнять A[i+1]
    jgtz obmen; если A[i] > A[i+1] то обменять значения
ret:    ; возврат после обмена
;СЛЕДУЮЩЕЕ I
    load 5  ; I = 1
    add =1   ; увеличить счетчик
    store 5 ; I = I+1
; N-J-1 - I > 0
    load 1  ; N
    sub 4   ; -J
    add =1  ; проверка гипотезы
    sub 5   ; -I
    jgtz loopi
; ЕСЛИ F=0 ТО ВЫХОД ИЗ ЦИКЛА
    load 3  ; загрузить F
    jz final
; СЛЕДУЮЩЕЕ J
    load 4  ; загузить J
    add =1   ; увеличить счетчик
    store 4 ; J = J + 1
; N-1 - J > 0
    load 1  ; N
    sub 4   ; -J
    jgtz loopj
    jmp final

obmen:  ;   подпрограмма обмена
    load *6     ; загрузить A[i]
    store 10    ; сохранить в регистр для обмена
    load *7     ; загрузить A[i+1]
    store *6    ; поместить на место A[i]
    load 10     ; извлечть из регистра для обмена
    store *7    ; поместить на место A[i+1]
    load =1     ; изменить флаг F
    store 3     ; обновить F
    jmp ret ;   возврат из п/п

final:
;   вывод результатов
;   инициализация J
    load =1
    store 4 ;начальное значение K
; ЦИКЛ ДЛЯ K=1 ДО N ШАГ 1
loopK:
    load 4  ; K = 1
    add =10  ; получить номер регистра, где хранится A[k], 11 для k=1
    store 6 ; соханить номер в R6
    write *6 ; напечатать
; СЛЕДУЮЩЕЕ J
    load 4  ; загузить K
    add =1   ; увеличить счетчик
    store 4 ; K = K + 1
; N - K > 0
    load 1  ; N
    sub 4   ; -K
    add =1
    jgtz loopK

    halt
